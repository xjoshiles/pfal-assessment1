to-do:


question difficulty when viewing set
delete users from admin panel
spacing at bottom of pages
delete button on reviews


backend tests and OpenAPI file
frontend tests
readme and setup guides


logout in sidebar notification???



node ace make:test posts/create --suite=functional

Run unit tests:
 node ace test unit

Run integration tests:
 node ace test integration

Run functional tests:
 node ace test functional

Run all tests:
 node ace test

Specific file (from backend directory):
 node ace test --files tests/functional/sets/store.spec.ts


node ace test integration /sets/store

if a belongs to b, deleting b should delete a
if a belongs to b, deleting a should not affect a





If you're sending an actual HTTP request to the POST /users endpoint to test
the API workflow, it's a functional test. Functional tests focus on the
application as a whole from the end-user's perspective. Testing the
creation of a user via the API simulates an actual workflow that
an end-user or client (e.g., frontend app) would perform.
They validate the entire process.

If you're directly testing the store method without using the HTTP layer,
it's an integration test. Integration tests are narrower in scope. If you
were only testing how the UsersController.store method interacts with the
RegisterUserValidator and the User model in isolation, without involving
the full HTTP stack (routes, middleware, etc.), that would be an
integration test.

A unit test focuses on testing the smallest, isolated pieces of your
application—often a single function, method, or class—without involving
any external dependencies or interactions with other parts of the
application. Unit tests are designed to validate the internal
logic of the unit under test.

Characteristics of Unit Tests
- Isolated: Each test targets only one "unit" of code, such as a function,
  method, or a small class. There is no interaction with the database, HTTP
  requests, or other external systems.
- Fast Execution: Since unit tests don't depend on external resources
  (e.g., a database or API), they are very fast to execute.
- Mocked Dependencies: If a function depends on external resources or other
  methods, those dependencies are mocked or stubbed.
- Specific: They are granular and test a single, well-defined behavior.
- Purpose: To ensure the internal logic of the function or method works as
  expected.




╔═════════════════════╤══════════════════════════════════════════════╤═════════════════════════════════════════════════╤═══════════════════════════════════════════════╗
║ Aspect              │ Unit Test                                    │ Integration Test                                │ Functional Test                               ║
╠═════════════════════╪══════════════════════════════════════════════╪═════════════════════════════════════════════════╪═══════════════════════════════════════════════╣
║ Scope               │ A single function or class.                  │ Interaction between components.                 │ Full-stack workflow of a feature.             ║
╟─────────────────────┼──────────────────────────────────────────────┼─────────────────────────────────────────────────┼───────────────────────────────────────────────╢
║ Dependencies        │ None (all dependencies mocked/stubbed).      │ Involves real interactions between components.  │ Real HTTP requests and database connections.  ║
╟─────────────────────┼──────────────────────────────────────────────┼─────────────────────────────────────────────────┼───────────────────────────────────────────────╢
║ Purpose             │ Validate internal logic of a function/class. │ Validate interactions between specific parts.   │ Validate the entire system as a user sees it. ║
╟─────────────────────┼──────────────────────────────────────────────┼─────────────────────────────────────────────────┼───────────────────────────────────────────────╢
║ Example in Your App │ User model's password hashing.               │ Controller method interacting with a validator. │ POST /users endpoint creating a user.         ║
╚═════════════════════╧══════════════════════════════════════════════╧═════════════════════════════════════════════════╧═══════════════════════════════════════════════╝






ItemsPanel component?... What does it need?:
- needs to be able to sort items based on updatedAt attribute
  could pass custom handleSortChange function (could sort collections by # sets)?
- needs to be able to accept either a setPreview or collectionPreview component

When user creates set or collection, take them to their library with
the relevant tab selected.

vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
View, Edit, and Delete buttons on previews in My Library
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


instead of my library page, should be /users/[id], with the following tabs:
- Flashcard Sets
- Collections
- Reviews (need get reviews by user id, should preload the associated set)
- Account management (if user id is the currently logged in user)
- Admin panel (if user id is the currently logged in user and an admin)

Redirect to user's library in middleware (check user cookie)
and upon login (return userId from login.ts API route to login page)?



SetsPanel
CollectionsPanel
Could generalise these and give custom sorting options, optional create button

Add auth to get flashcard set by id and get collection by id in controllers?


openAPI file, adonis's default error response if unauthorised (no valid token).
Not sure if I can override this or mention in the yaml:
{
    "errors": [
        {
            "message": "Unauthorized access"
        }
    ]
}


frontend tests?
Use Toast component throughout application




difficulty when doing a flashcard


return 404 page on frontend if flashcard set not found


Consider removing userId and Username from flashcard/collection models/migrations,
as I can preload the creator attribute which contains those details.


    // If we are sending a body with application/json, it must be a valid
    // json object or undefined. To get past this, we can use text/html
    // which allows plain text such as empty strings.




Perhaps we should provide a message and an error throughout our controllers?






benefit of a user context is that I don't need to make a request
for rendering user settings pages, or knowing who the current user
is for reviews etc. Also no prop drilling...

- Easier to reload navbar?
- Easier to get current user for reviews?
- Eaiser to detect on frontend if admin is trying to remove their admin status?

Where would I be prop drilling in my application with the user info?
I can fetch user info from cookies on user settings server component
and then render the required client components accordingly...
I can pass the current user object to my reviews section from
/sets/[id]/page.tsx...
That's not drilling, it's only a single passing of arguments.




Update auth controller login method to return user object in response
Update Next.js login/logout API routes to parse the response and set
the sessionToken and userInfo cookies.
>> (currently calling data.token.token in login route...)

Update middleware to clear both cookies if validation fails.
Utilise types and importable values for cleaner code.


"
For Server-side code in utility files or modules: Use import 'server-only'.
This ensures that the code doesn’t get bundled with the client-side code and runs only on the server.

For React Server Components: Use 'use server' in the component file to specify that the component should render on the server side.
"



Update the context when the user logs in or logs out,
then navbar will update when using the same context?


We can't set the user data in the headers as it can't be retrieved via
an API call from client components as the headers aren't persistent
(you get undefined in the API handler), so we set a cookie instead.
We could use localstorage but this would be somewhat insecure.



don't redirect to dashboard in the middleware, do it on the /login or /register
pages themselves?

We can put the following in the pages to prevent rendering while redirecting:
  // If the user is already logged in, redirect them to /dashboard
  if (user) {
    router.push('/dashboard');
    return null; // Prevent rendering the page while redirecting
  }
before the return html






change my /auth/me controller method to POST instead of GET, and change
method type on all requests in my nextjs application.

Simplifying my requests to backend api...
protecting pages such as /sets/create...

Is my api wrapper [...path].ts efficient? Not just the code, but using
this approach in the first place. Perhaps explicit dedicated api routes
would be more efficient than the wrapper, but also more management and work.

If I use a context to store the session and the token expires, would the
session still be active on the frontend? I would need to periodically
check it right? Would this be whenever the user navigates to a new page
or what? If it's on every page load, why would I need a context? I could
simply query /api/auth/me and receive the user object within that page.
Currently my navbar queries it. If I stored this in a context I could
use those states to render parts of the page e.g. admin controls,
and know what user is signed in for comments etc.?
This is better than my navbar requests, the middleware requests (protecting
a page such as /sets/2, and the comments page requests for user info.

I am trying to validate the user session on every page load, and then
using this information throughout my application. My validation should
be server side, and I believe that the best way to propogate this
information throughout my application is through the use of a context
rather than prop drilling. Is getServerSideProps necessary here if the
user session isn't indexable by search engines? How would I pass this
information to my context if it is validated on server components?





Cookies notes:
- Cookies Automatically Sent by the Browser:
  - When making a request to the same domain/origin (or subdomain if
    SameSite=Strict/Lax), the browser will automatically include
    the cookies in the request headers. This is handled by the BROWSER.

My cookies have the following attributes:
- HttpOnly: true  ... the cookie cannot be accessed via JavaScript
  (e.g., document.cookie). This is a good security measure because
  it prevents the cookie from being exposed to client-side JavaScript,
  mitigating XSS vulnerabilities.
- SameSite: 'Strict'  ... the cookie will only be sent for requests
  originating from the same origin as the cookie's domain.

The SameSite: 'Strict' rule is why I can use Next.js API routes as a proxy for
my backend server. Specifically, the frontend (http://localhost:3000) interacts
with Next.js API routes (same-origin), and those routes make the actual request
to http://localhost:3333. The cookie is included in the request sent by the
client component and is retrieved in the Next.js API route handler via:
    const cookies = parse(req.headers.cookie || "")
    const token = cookies.sessionToken
or...
    const token = req.cookies?.sessionToken

Since I am using HttpOnly I CANNOT retrieve it via JavaScript
(e.g., document.cookie) within the client components. The only other way
the cookie can be sent is automatically BY THE BROWSER (dependent on SameSite)

Thus, because my cookies are SameSite: 'Strict', and HttpOnly: true,
there is no way to send the cookie during cross-origin requests from
my client components (http://localhost:3000) directly to my Adonis.js backend
(http://localhost:3333). The only solutions are to change my cookies to
SameSite=None (but this MUST use HTTPS, i.e. (secure: true)), setting HttpOnly
to false (exposing it to XSS vulnerabilities) or to use the Next.js API route.
So, Next.js API route(s) it is!

I can mitigate the performance impact of using a Next.js API route by making
requests directly to my Adonis.js API in server components, and then passing
the payload as props. For client component requests, the Next.js API
route proxy is essential.

To access cookies in a server component instead of an api route
(note that this is again subject to the cookie being sent automatically,
so it will work if the cookie was sent with SameSite: 'Strict' and created
by our Next.js application):
  import { cookies } from 'next/headers'
  // const cookieStore = cookies();
  const sessionToken = (await cookies()).get('sessionToken')?.value




Authentication notes:
- My implementation uses stateful authentication, since tokens are
  generated, stored, and validated in the backend (adonisjs with
  better-sqlite3). As such, the server is maintaining the session state,
  such as the token and other identifiers (username, admin status).
  This is done through a session store in the database. Each time a
  user makes a request, the server can look up the session information
  (like the session token) in the store and verify the user’s identity.

- Note that session tokens need to be explicitly invalidated (e.g., when
  logging out or after expiry). Thus, while we can log out on the
  client-side by deleting the cookie (they won't be authenticated with
  subsequent requests), notifying the backend to clean up or invalidate
  the session ensures that the token is marked as expired, deleted, or no
  longer valid, preventing any future unauthorized use of the same token.
  Since my adonijs implementation uses token expiration, simply deleting
  the cookie may suffice for most cases, as the token will expire after
  a certain period. However, deleting the token from the database or
  session store is still recommended to reduce potential risks.
  In the case of deletion, it also cleans up space in the database.

Advantages of stateful authentication (my approach):
  - Token Revocation: You can revoke a session on the backend by deleting
    the token from the database or marking it as invalid, which is not
    possible with stateless JWT authentication unless you implement
    a separate revocation mechanism.
  - Centralised Security: E.g. it can log the user out by deleting the
    session in the backend database, even if the client still has the cookie.
  - Security of Sensitive Data: In stateful authentication, only a session token
    or identifier is stored on the client (e.g. a cookie). Sensitive data such
    as user roles and personal details are stored securely on the backend.
    The server performs the actual verification, and the client only has the
    token (not the user’s full data). This is in contrast to stateless
    authentication, where you may store sensitive data directly in the token
    (which is possible but not recommended), which could be a risk if the token
    is exposed or intercepted, and not properly encrypted, as it would contain
    the sensitive data.

Disadvantages of stateful authentication (my approach):
- Each request requires an additional API call to the backend to validate
  the session token, adding overhead in terms of latency and server load.
- The backend needs to query the session store (database) each time to verify
  that the token or session is still valid. This is more resource-intensive
  compared to stateless approaches, where no such lookup is needed.

- In contrast, stateless authentication does not store session information on
  the server. Instead, the backend issues a token by signing it with a secret
  key. This ensures that the token is tamper-proof. The client holds the session
  token (typically JWT) in a cookie, which contains all necessary information
  for authentication and Authorisation (such as user ID, roles, and expiration).
  Then, when the client sends this token to the server, it is validated by:
  - The server verifies the token signature using the same secret key (this is
    why implementations have an encrypt and decrypt function for the token).
  - The server decodes the payload to extract the user data (such as user ID,
    roles, and expiration). The server does not need to query a session store
    because the token is self-contained and carries the authentication data.

Advantages of Stateless Authentication
- Reduced Backend Load: Because session validation doesn’t require querying a
  database or session store, stateless authentication can offer better
  performance and scalability, especially in microservices architectures.
- No Centralized Session Storage: Stateless authentication is decentralised,
  meaning no server needs to store session data. The client holds all the
  session information and can authenticate independently, leading to
  fewer server-side dependencies.
- Security: JWT tokens are tamper-proof due to the signature verification
  process, which ensures that the token hasn't been modified by the client.

Disadvantages of Stateless Authentication:
- Token Revocation Complexity: If a user logs out, changes their password, or
  you need to revoke a session for any other reason, there’s no straightforward
  way to invalidate the JWT. You'd have to implement a separate mechanism like
  a revocation list or blacklist (a database or memory store that tracks
  invalid tokens). Without a revocation system, a compromised or outdated token
  can still be used until it naturally expires, posing a security risk.
- Token Size: While small JWTs are efficient, as more claims (e.g., roles,
  permissions, or custom data) are added to the token, the size increases.
  This can result in larger payloads, especially if the token is included
  in every request header (via Authorization: Bearer token). Larger tokens
  increase the size of HTTP requests and responses, potentially leading to
  performance issues, especially if the tokens are sent with every request.

In conclusion:
╔════════════════╤══════════════════════════════╤══════════════════════════════════════════╗
║ Feature        │ JWT on Client                │ Backend Token Validation                 ║
╠════════════════╪══════════════════════════════╪══════════════════════════════════════════╣
║ Validation     │ Local (client-side)          │ Backend API                              ║
╟────────────────┼──────────────────────────────┼──────────────────────────────────────────╢
║ Implementation │ Decode token in Next.js      │ Forward token to AdonisJS for validation ║
╟────────────────┼──────────────────────────────┼──────────────────────────────────────────╢
║ Performance    │ Faster (no network call)     │ Slower (extra API call)                  ║
╟────────────────┼──────────────────────────────┼──────────────────────────────────────────╢
║ Complexity     │ Requires JWT library & setup │ Simpler if backend handles all tokens    ║
╟────────────────┼──────────────────────────────┼──────────────────────────────────────────╢
║ Use Case       │ Stateless, scalable apps     │ Stateful, backend-managed sessions       ║
╚════════════════╧══════════════════════════════╧══════════════════════════════════════════╝





"Summary
While JWTs and cookies are different concepts:

JWT is a token format (used for authentication and authorization).
Cookies are a storage and transport mechanism.
You can use JWTs in cookies when:

1. You want the browser to handle token storage and transport.
2. Security concerns like XSS (HttpOnly) or CSRF (SameSite) need to be addressed.
3. You're building traditional web apps or hybrid architectures that benefit
from cookie management.

For SPAs, you may opt to store the JWT outside cookies (e.g., in localStorage)
if you want fine-grained control over headers, but ensure you address XSS risks".






Put buttons next to each other
Put error message below buttons.
Move to /sets/create/page.tsx?



Error messages in create-set (store on controller)
edit set page
create and browse collections page


write readmes
adonisjs:
cd into backend
npm install
cp .env.example .env
node ace generate:key
node ace migration:run

Run tests (optional):
npm test





auth_access_token has an 'expires_at' column. Can we set this to 1 month
after the creation date and have it auto delete when it expires?

Need a check in delete user method in backend that if they are admin,
and are the only admin, not to delete.

So, how do we limit what the user sees based on their authentication?

Should we return all error messages from the API (auth_controller no longer does)
and only display the first one on the frontend?

- Could my routes be written better?
- random method in collections_controller
- comment users_controller
- should the validation happen within the try block in my controllers?
- do I need any other methods in my comments controller, e.g. delete?
- try block on store method on comments controller?

Questions for Zoltan:
- when do we get access to the tests?
- request body of create new / update collection
- Is my implementation of the update and destroy methods ideal?
  I'm finding the desired sets/collections and then matching user
  IDs or admin status before performing the operations.
  This is because I also want admins to be able to perform these operations,
  regardless of whether or not they are the creator. The request url
  for updating a set doesn't specify a user id, but the collection one
  does. Should this have any influence on my implementation?
  The userId parameter isn't even being used...
- do we return a redirect or a random collection?

- For frontend, use intertia (adocasts playlist), don't need 

- groups for routes

- vvvv Not done
- /collections/random - Redirect to a random flashcard set collection

- vvvv Test these:
- /users/{userId}/collections
- /users/{userId}/collections/{collectionId}
- /users/{userId}/collections/{collectionId}
- /users/{userId}/collections/{collectionId}
- /sets/{setId}       - Update flashcard set by ID
- /users/{userId}     - Update a user by ID


- ENSURE WE ARE NOT USING A RELEASE CANDIDATE VERSION OF REACT


- Should we delete previous access tokens in auth_controller?
- Should we return a message on success in some controllers too?
- Return flashcards in a set in flashcards_controller store method
- get api version (top of OpenAPI spec)
- implement limit of 20 flashcard sets per day (modifiable)
- user sign up with username and password
- give admins their own dashboard from within which they can
  select a user, modify their admin status and flashcard limits.
- give users their own account dashboard where they can change
  their passwords (and maybe usernames?)



To safely delete a migration file:
- node ace migration:status     (make sure it is pending, i.e. not completed)
- delete the file
- node ace migration:refresh
- node ace migration:status     (ensure that it is gone)

node ace migration:rollback --all
node ace migration:run
node ace migration:reset
node ace db:seed --files "database/seeders/admin_user_seeder.ts"

node ace repl
const { default: User } = await import("#models/user")
const user = await User.find(1) // Replace 1 with the actual user ID
await user.delete()



Get routes:
node ace list:routes


auto-indent code:
shift + alt + f


"If you are using the @adonisjs/auth module, hashing passwords within your
model is unnecessary. The AuthFinder automatically handles password hashing,
ensuring your user credentials are securely processed. Learn more about
this process here".


Can collections have comments?

A FlashcardSet can have many Collections, and a Collection can have many
FlashcardSets.



Practical issues with REST
tight coupling, needs update to OpenAPI file, and then update to at least
two code bases (nackend and frontend)

GraphQL. Frontend decides which field it queries








Old code:

      // // Delete previous flashcards associated with the set
      // await Flashcard.query({ client: trx })
      //   .where('flashcardSetId', set.id).delete();

      // // Prepare the flashcards with the flashcard set ID
      // const flashcardsData = payload.flashcards.map((flashcard) => ({
      //   ...flashcard,
      //   flashcardSetId: set.id,
      // }))

      // // Create flashcards in the flashcard table
      // await Flashcard.createMany(flashcardsData, { client: trx })



    // const collections = await Collection.query()
    //   .whereExists((builder) => {
    //     builder.select('*')
    //       .from('collection_flashcard_sets') // the pivot table
    //       .where('collection_flashcard_sets.flashcard_set_id', flashcardSet.id)
    //   })


  public static async UpdateCollectionAverages(flashcardSet: FlashcardSet) {
    // Get the collections this FlashcardSet belongs to
    const collections = await flashcardSet.related('collections').query()

    // Update the average rating for each collection
    for (const collection of collections) {
      const sets = await collection.related('flashcardSets').query()

      // Calculate the new average for this collection
      const collectionAvgResult = await FlashcardSet.query()
        .whereIn('id', sets.map((set) => set.id))
        .avg('average_rating as averageRating')
        .first()

      const averageRating = collectionAvgResult?.$extras.averageRating || 0
      console.log(averageRating)
      // Update the collection's average rating
      await Collection.query()
        .where('id', collection.id)
        .update({ averageRating: averageRating })
    }
  }

    // @beforeSave()
  // public static preventUpdatedAt(instance: FlashcardSet) {
  //   const changes = instance.$dirty  // which fields are being updated

  //   // Prevent updating the updatedAt column if
  //   // only the averageRating field has changed
  //   if (Object.keys(changes).length === 1 && 'averageRating' in changes) {
  //     return

  //   } else {
  //     // Manually update 'updatedAt' only when other fields are dirty
  //     instance.updatedAt = DateTime.local()
  //   }
  // }