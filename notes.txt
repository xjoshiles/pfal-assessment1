to-do:



frontend tests?
Use Toast component throughout application


New nav bar with icons?:
// Jack got icons from import { TrashIcon } from '@heroicons/react/24/outline'
// Joel got icons from "ion icons"
// Both are installable

Create collections
View collections (is there anything in openapi that implies collections
should be visible to other users? YES, GET ALL FLASHCARD SET COLLECTIONS)

library: sets and collections, with tabs? This will give user create/edit options


admin panel in navbar (if user is admin)

difficulty when doing a flashcard

return 404 page on frontend if flashcard set not found


Consider removing userId and Username from flashcard/collection models/migrations,
as I can preload the creator attribute which contains those details.


    // If we are sending a body with application/json, it must be a valid
    // json object or undefined. To get past this, we can use text/html
    // which allows plain text such as empty strings.




Perhaps we should provide a message and an error throughout our controllers?


My Library   Sets   Collections   Logout   josh

Account, Admin

???



benefit of a user context is that I don't need to make a request
for rendering user settings pages, or knowing who the current user
is for reviews etc. Also no prop drilling...

- Easier to reload navbar?
- Easier to get current user for reviews?
- Eaiser to detect on frontend if admin is trying to remove their admin status?

Where would I be prop drilling in my application with the user info?
I can fetch user info from cookies on user settings server component
and then render the required client components accordingly...
I can pass the current user object to my reviews section from
/sets/[id]/page.tsx...
That's not drilling, it's only a single passing of arguments.




Update auth controller login method to return user object in response
Update Next.js login/logout API routes to parse the response and set
the sessionToken and userInfo cookies.
>> (currently calling data.token.token in login route...)

Update middleware to clear both cookies if validation fails.
Utilise types and importable values for cleaner code.


"
For Server-side code in utility files or modules: Use import 'server-only'.
This ensures that the code doesn’t get bundled with the client-side code and runs only on the server.

For React Server Components: Use 'use server' in the component file to specify that the component should render on the server side.
"



Update the context when the user logs in or logs out,
then navbar will update when using the same context?


We can't set the user data in the headers as it can't be retrieved via
an API call from client components as the headers aren't persistent
(you get undefined in the API handler), so we set a cookie instead.
We could use localstorage but this would be somewhat insecure.



don't redirect to dashboard in the middleware, do it on the /login or /register
pages themselves?

We can put the following in the pages to prevent rendering while redirecting:
  // If the user is already logged in, redirect them to /dashboard
  if (user) {
    router.push('/dashboard');
    return null; // Prevent rendering the page while redirecting
  }
before the return html






change my /auth/me controller method to POST instead of GET, and change
method type on all requests in my nextjs application.

Simplifying my requests to backend api...
protecting pages such as /sets/create...

Is my api wrapper [...path].ts efficient? Not just the code, but using
this approach in the first place. Perhaps explicit dedicated api routes
would be more efficient than the wrapper, but also more management and work.

If I use a context to store the session and the token expires, would the
session still be active on the frontend? I would need to periodically
check it right? Would this be whenever the user navigates to a new page
or what? If it's on every page load, why would I need a context? I could
simply query /api/auth/me and receive the user object within that page.
Currently my navbar queries it. If I stored this in a context I could
use those states to render parts of the page e.g. admin controls,
and know what user is signed in for comments etc.?
This is better than my navbar requests, the middleware requests (protecting
a page such as /sets/2, and the comments page requests for user info.

I am trying to validate the user session on every page load, and then
using this information throughout my application. My validation should
be server side, and I believe that the best way to propogate this
information throughout my application is through the use of a context
rather than prop drilling. Is getServerSideProps necessary here if the
user session isn't indexable by search engines? How would I pass this
information to my context if it is validated on server components?





Cookies notes:
- Cookies Automatically Sent by the Browser:
  - When making a request to the same domain/origin (or subdomain if
    SameSite=Strict/Lax), the browser will automatically include
    the cookies in the request headers. This is handled by the BROWSER.

My cookies have the following attributes:
- HttpOnly: true  ... the cookie cannot be accessed via JavaScript
  (e.g., document.cookie). This is a good security measure because
  it prevents the cookie from being exposed to client-side JavaScript,
  mitigating XSS vulnerabilities.
- SameSite: 'Strict'  ... the cookie will only be sent for requests
  originating from the same origin as the cookie's domain.

The SameSite: 'Strict' rule is why I can use Next.js API routes as a proxy for
my backend server. Specifically, the frontend (http://localhost:3000) interacts
with Next.js API routes (same-origin), and those routes make the actual request
to http://localhost:3333. The cookie is included in the request sent by the
client component and is retrieved in the Next.js API route handler via:
    const cookies = parse(req.headers.cookie || "")
    const token = cookies.sessionToken
or...
    const token = req.cookies?.sessionToken

Since I am using HttpOnly I CANNOT retrieve it via JavaScript
(e.g., document.cookie) within the client components. The only other way
the cookie can be sent is automatically BY THE BROWSER (dependent on SameSite)

Thus, because my cookies are SameSite: 'Strict', and HttpOnly: true,
there is no way to send the cookie during cross-origin requests from
my client components (http://localhost:3000) directly to my Adonis.js backend
(http://localhost:3333). The only solutions are to change my cookies to
SameSite=None (but this MUST use HTTPS, i.e. (secure: true)), setting HttpOnly
to false (exposing it to XSS vulnerabilities) or to use the Next.js API route.
So, Next.js API route(s) it is!

I can mitigate the performance impact of using a Next.js API route by making
requests directly to my Adonis.js API in server components, and then passing
the payload as props. For client component requests, the Next.js API
route proxy is essential.

To access cookies in a server component instead of an api route
(note that this is again subject to the cookie being sent automatically,
so it will work if the cookie was sent with SameSite: 'Strict' and created
by our Next.js application):
  import { cookies } from 'next/headers'
  // const cookieStore = cookies();
  const sessionToken = (await cookies()).get('sessionToken')?.value




Authentication notes:
- My implementation uses stateful authentication, since tokens are
  generated, stored, and validated in the backend (adonisjs with
  better-sqlite3). As such, the server is maintaining the session state,
  such as the token and other identifiers (username, admin status).
  This is done through a session store in the database. Each time a
  user makes a request, the server can look up the session information
  (like the session token) in the store and verify the user’s identity.

- Note that session tokens need to be explicitly invalidated (e.g., when
  logging out or after expiry). Thus, while we can log out on the
  client-side by deleting the cookie (they won't be authenticated with
  subsequent requests), notifying the backend to clean up or invalidate
  the session ensures that the token is marked as expired, deleted, or no
  longer valid, preventing any future unauthorized use of the same token.
  Since my adonijs implementation uses token expiration, simply deleting
  the cookie may suffice for most cases, as the token will expire after
  a certain period. However, deleting the token from the database or
  session store is still recommended to reduce potential risks.
  In the case of deletion, it also cleans up space in the database.

Advantages of stateful authentication (my approach):
  - Token Revocation: You can revoke a session on the backend by deleting
    the token from the database or marking it as invalid, which is not
    possible with stateless JWT authentication unless you implement
    a separate revocation mechanism.
  - Centralised Security: E.g. it can log the user out by deleting the
    session in the backend database, even if the client still has the cookie.
  - Security of Sensitive Data: In stateful authentication, only a session token
    or identifier is stored on the client (e.g. a cookie). Sensitive data such
    as user roles and personal details are stored securely on the backend.
    The server performs the actual verification, and the client only has the
    token (not the user’s full data). This is in contrast to stateless
    authentication, where you may store sensitive data directly in the token
    (which is possible but not recommended), which could be a risk if the token
    is exposed or intercepted, and not properly encrypted, as it would contain
    the sensitive data.

Disadvantages of stateful authentication (my approach):
- Each request requires an additional API call to the backend to validate
  the session token, adding overhead in terms of latency and server load.
- The backend needs to query the session store (database) each time to verify
  that the token or session is still valid. This is more resource-intensive
  compared to stateless approaches, where no such lookup is needed.

- In contrast, stateless authentication does not store session information on
  the server. Instead, the backend issues a token by signing it with a secret
  key. This ensures that the token is tamper-proof. The client holds the session
  token (typically JWT) in a cookie, which contains all necessary information
  for authentication and Authorisation (such as user ID, roles, and expiration).
  Then, when the client sends this token to the server, it is validated by:
  - The server verifies the token signature using the same secret key (this is
    why implementations have an encrypt and decrypt function for the token).
  - The server decodes the payload to extract the user data (such as user ID,
    roles, and expiration). The server does not need to query a session store
    because the token is self-contained and carries the authentication data.

Advantages of Stateless Authentication
- Reduced Backend Load: Because session validation doesn’t require querying a
  database or session store, stateless authentication can offer better
  performance and scalability, especially in microservices architectures.
- No Centralized Session Storage: Stateless authentication is decentralised,
  meaning no server needs to store session data. The client holds all the
  session information and can authenticate independently, leading to
  fewer server-side dependencies.
- Security: JWT tokens are tamper-proof due to the signature verification
  process, which ensures that the token hasn't been modified by the client.

Disadvantages of Stateless Authentication:
- Token Revocation Complexity: If a user logs out, changes their password, or
  you need to revoke a session for any other reason, there’s no straightforward
  way to invalidate the JWT. You'd have to implement a separate mechanism like
  a revocation list or blacklist (a database or memory store that tracks
  invalid tokens). Without a revocation system, a compromised or outdated token
  can still be used until it naturally expires, posing a security risk.
- Token Size: While small JWTs are efficient, as more claims (e.g., roles,
  permissions, or custom data) are added to the token, the size increases.
  This can result in larger payloads, especially if the token is included
  in every request header (via Authorization: Bearer token). Larger tokens
  increase the size of HTTP requests and responses, potentially leading to
  performance issues, especially if the tokens are sent with every request.

In conclusion:
╔════════════════╤══════════════════════════════╤══════════════════════════════════════════╗
║ Feature        │ JWT on Client                │ Backend Token Validation                 ║
╠════════════════╪══════════════════════════════╪══════════════════════════════════════════╣
║ Validation     │ Local (client-side)          │ Backend API                              ║
╟────────────────┼──────────────────────────────┼──────────────────────────────────────────╢
║ Implementation │ Decode token in Next.js      │ Forward token to AdonisJS for validation ║
╟────────────────┼──────────────────────────────┼──────────────────────────────────────────╢
║ Performance    │ Faster (no network call)     │ Slower (extra API call)                  ║
╟────────────────┼──────────────────────────────┼──────────────────────────────────────────╢
║ Complexity     │ Requires JWT library & setup │ Simpler if backend handles all tokens    ║
╟────────────────┼──────────────────────────────┼──────────────────────────────────────────╢
║ Use Case       │ Stateless, scalable apps     │ Stateful, backend-managed sessions       ║
╚════════════════╧══════════════════════════════╧══════════════════════════════════════════╝





"Summary
While JWTs and cookies are different concepts:

JWT is a token format (used for authentication and authorization).
Cookies are a storage and transport mechanism.
You can use JWTs in cookies when:

1. You want the browser to handle token storage and transport.
2. Security concerns like XSS (HttpOnly) or CSRF (SameSite) need to be addressed.
3. You're building traditional web apps or hybrid architectures that benefit
from cookie management.

For SPAs, you may opt to store the JWT outside cookies (e.g., in localStorage)
if you want fine-grained control over headers, but ensure you address XSS risks".






Put buttons next to each other
Put error message below buttons.
Move to /sets/create/page.tsx?



Error messages in create-set (store on controller)
edit set page
create and browse collections page


write readmes
adonisjs:
cd into backend
npm install
cp .env.example .env
node ace generate:key
node ace migration:run

Run tests (optional):
npm test





auth_access_token has an 'expires_at' column. Can we set this to 1 month
after the creation date and have it auto delete when it expires?

Need a check in delete user method in backend that if they are admin,
and are the only admin, not to delete.

So, how do we limit what the user sees based on their authentication?

Should we return all error messages from the API (auth_controller no longer does)
and only display the first one on the frontend?

- Could my routes be written better?
- random method in collections_controller
- comment users_controller
- should the validation happen within the try block in my controllers?
- do I need any other methods in my comments controller, e.g. delete?
- try block on store method on comments controller?

Questions for Zoltan:
- when do we get access to the tests?
- request body of create new / update collection
- Is my implementation of the update and destroy methods ideal?
  I'm finding the desired sets/collections and then matching user
  IDs or admin status before performing the operations.
  This is because I also want admins to be able to perform these operations,
  regardless of whether or not they are the creator. The request url
  for updating a set doesn't specify a user id, but the collection one
  does. Should this have any influence on my implementation?
  The userId parameter isn't even being used...
- do we return a redirect or a random collection?

- For frontend, use intertia (adocasts playlist), don't need 

- groups for routes

- vvvv Not done
- /collections/random - Redirect to a random flashcard set collection

- vvvv Test these:
- /users/{userId}/collections
- /users/{userId}/collections/{collectionId}
- /users/{userId}/collections/{collectionId}
- /users/{userId}/collections/{collectionId}
- /sets/{setId}       - Update flashcard set by ID
- /users/{userId}     - Update a user by ID


- ENSURE WE ARE NOT USING A RELEASE CANDIDATE VERSION OF REACT


- Should we delete previous access tokens in auth_controller?
- Should we return a message on success in some controllers too?
- Return flashcards in a set in flashcards_controller store method
- get api version (top of OpenAPI spec)
- implement limit of 20 flashcard sets per day (modifiable)
- user sign up with username and password
- give admins their own dashboard from within which they can
  select a user, modify their admin status and flashcard limits.
- give users their own account dashboard where they can change
  their passwords (and maybe usernames?)



To safely delete a migration file:
- node ace migration:status     (make sure it is pending, i.e. not completed)
- delete the file
- node ace migration:refresh
- node ace migration:status     (ensure that it is gone)

node ace migration:rollback --all
node ace migration:run
node ace migration:reset
node ace db:seed --files "database/seeders/admin_user_seeder.ts"

node ace repl
const { default: User } = await import("#models/user")
const user = await User.find(1) // Replace 1 with the actual user ID
await user.delete()



Get routes:
node ace list:routes


auto-indent code:
shift + alt + f


"If you are using the @adonisjs/auth module, hashing passwords within your
model is unnecessary. The AuthFinder automatically handles password hashing,
ensuring your user credentials are securely processed. Learn more about
this process here".


Can collections have comments?

A FlashcardSet can have many Collections, and a Collection can have many
FlashcardSets.



Practical issues with REST
tight coupling, needs update to OpenAPI file, and then update to at least
two code bases (nackend and frontend)

GraphQL. Frontend decides which field it queries








Old code:

      // // Delete previous flashcards associated with the set
      // await Flashcard.query({ client: trx })
      //   .where('flashcardSetId', set.id).delete();

      // // Prepare the flashcards with the flashcard set ID
      // const flashcardsData = payload.flashcards.map((flashcard) => ({
      //   ...flashcard,
      //   flashcardSetId: set.id,
      // }))

      // // Create flashcards in the flashcard table
      // await Flashcard.createMany(flashcardsData, { client: trx })
